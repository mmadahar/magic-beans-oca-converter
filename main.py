#!/usr/bin/env python3
"""
OCA File Analyzer - Tool to understand A1 Evo Express .oca files

This utility helps analyze Audyssey calibration files (.oca) generated by
A1 Evo Express for Denon/Marantz AV receivers. It focuses on understanding
the filter data structure for custom target curve uploads.

Usage:
    uv run python main.py summary
    uv run python main.py list-channels
    uv run python main.py inspect-filter 0
    uv run python main.py chunk-filter 0 --start 0 --size 100
    uv run python main.py export-filter 0 output.csv
    uv run python main.py compare-channels
"""

import json
import csv
import sys
from pathlib import Path
from typing import Dict, List, Any
import statistics


class OCAAnalyzer:
    """Analyzer for A1 Evo Express .oca files"""

    def __init__(self, oca_file_path: str):
        self.oca_file = Path(oca_file_path)
        self.data = None
        self._load_file()

    def _load_file(self):
        """Load the OCA JSON file"""
        print(f"Loading {self.oca_file.name}...")
        with open(self.oca_file, 'r') as f:
            self.data = json.load(f)
        print(f"✓ Loaded successfully\n")

    def summary(self):
        """Display top-level configuration summary"""
        print("=" * 70)
        print("OCA FILE SUMMARY")
        print("=" * 70)

        # Main metadata
        print(f"\nA1 Evo Express Version: {self.data.get('A1EvoExpress', 'N/A')}")
        print(f"Receiver Model: {self.data.get('model', 'N/A')}")
        print(f"EQ Type: {self.data.get('eqType', 'N/A')}")
        print(f"Has Griffin Lite DSP: {self.data.get('hasGriffinLiteDSP', 'N/A')}")
        print(f"Is New Model: {self.data.get('isNewModel', 'N/A')}")

        # Amp configuration
        print(f"\nAmp Assignment: {self.data.get('ampAssign', 'N/A')}")
        print(f"Amp Assignment Info: {self.data.get('ampAssignInfo', 'N/A')[:50]}...")

        # Bass/LFE settings
        print(f"\nNumber of Subwoofers: {self.data.get('numberOfSubwoofers', 'N/A')}")
        print(f"LPF for LFE: {self.data.get('lpfForLFE', 'N/A')}")
        print(f"Bass Mode: {self.data.get('bassMode', 'N/A')}")

        # Channel count
        channels = self.data.get('channels', [])
        print(f"\nTotal Channels: {len(channels)}")

        print("=" * 70)

    def list_channels(self):
        """List all channels with their properties"""
        print("=" * 70)
        print("CHANNEL OVERVIEW")
        print("=" * 70)

        channels = self.data.get('channels', [])

        for i, ch in enumerate(channels):
            print(f"\n--- Channel {i} ---")
            print(f"  Speaker Type: {ch.get('speakerType', 'N/A')}")
            print(f"  Distance: {ch.get('distanceInMeters', 'N/A')} meters")
            print(f"  Trim Adjustment: {ch.get('trimAdjustmentInDbs', 'N/A')} dB")
            print(f"  Crossover: {ch.get('xover', 'N/A')}")
            print(f"  Command ID: {ch.get('commandId', 'N/A')}")

            # Filter info
            filter_data = ch.get('filter', [])
            filterLV_data = ch.get('filterLV', [])
            print(f"  Filter Length: {len(filter_data)} coefficients")
            print(f"  FilterLV Length: {len(filterLV_data)} coefficients")

        print("=" * 70)

    def inspect_filter(self, channel_num: int, preview_size: int = 20):
        """Inspect a specific channel's filter in detail"""
        channels = self.data.get('channels', [])

        if channel_num < 0 or channel_num >= len(channels):
            print(f"Error: Channel {channel_num} not found. Valid range: 0-{len(channels)-1}")
            return

        ch = channels[channel_num]
        filter_data = ch.get('filter', [])

        print("=" * 70)
        print(f"FILTER INSPECTION - Channel {channel_num}")
        print("=" * 70)

        print(f"\nChannel Info:")
        print(f"  Speaker Type: {ch.get('speakerType', 'N/A')}")
        print(f"  Distance: {ch.get('distanceInMeters', 'N/A')} meters")
        print(f"  Trim: {ch.get('trimAdjustmentInDbs', 'N/A')} dB")
        print(f"  Crossover: {ch.get('xover', 'N/A')}")

        print(f"\nFilter Statistics:")
        print(f"  Total Coefficients: {len(filter_data)}")

        if filter_data:
            print(f"  Min Value: {min(filter_data):.10f}")
            print(f"  Max Value: {max(filter_data):.10f}")
            print(f"  Mean: {statistics.mean(filter_data):.10f}")
            print(f"  Median: {statistics.median(filter_data):.10f}")
            print(f"  Std Dev: {statistics.stdev(filter_data):.10f}")

            # Show first coefficients
            print(f"\nFirst {preview_size} coefficients:")
            for i, val in enumerate(filter_data[:preview_size]):
                print(f"  [{i:4d}] = {val:.10f}")

            # Show last coefficients
            print(f"\nLast {preview_size} coefficients:")
            start_idx = len(filter_data) - preview_size
            for i, val in enumerate(filter_data[-preview_size:], start=start_idx):
                print(f"  [{i:4d}] = {val:.10f}")

        print("=" * 70)

    def chunk_filter(self, channel_num: int, start: int = 0, size: int = 100):
        """Read filter data in chunks"""
        channels = self.data.get('channels', [])

        if channel_num < 0 or channel_num >= len(channels):
            print(f"Error: Channel {channel_num} not found. Valid range: 0-{len(channels)-1}")
            return

        ch = channels[channel_num]
        filter_data = ch.get('filter', [])

        if start < 0 or start >= len(filter_data):
            print(f"Error: Start index {start} out of range. Valid range: 0-{len(filter_data)-1}")
            return

        end = min(start + size, len(filter_data))

        print("=" * 70)
        print(f"FILTER CHUNK - Channel {channel_num}")
        print("=" * 70)
        print(f"Range: [{start}:{end}] ({end - start} coefficients)")
        print(f"Total filter length: {len(filter_data)}")
        print()

        for i in range(start, end):
            print(f"  [{i:5d}] = {filter_data[i]:.10f}")

        print("=" * 70)

    def export_filter_csv(self, channel_num: int, output_file: str):
        """Export filter coefficients to CSV file"""
        channels = self.data.get('channels', [])

        if channel_num < 0 or channel_num >= len(channels):
            print(f"Error: Channel {channel_num} not found. Valid range: 0-{len(channels)-1}")
            return

        ch = channels[channel_num]
        filter_data = ch.get('filter', [])

        output_path = Path(output_file)

        print(f"Exporting Channel {channel_num} filter to {output_path}...")

        with open(output_path, 'w', newline='') as csvfile:
            writer = csv.writer(csvfile)
            writer.writerow(['Index', 'Coefficient'])

            for i, val in enumerate(filter_data):
                writer.writerow([i, val])

        print(f"✓ Exported {len(filter_data)} coefficients to {output_path}")
        print(f"  You can now open this in Excel or use it for plotting/analysis")

    def compare_channels(self):
        """Compare filters across all channels"""
        print("=" * 70)
        print("CHANNEL COMPARISON")
        print("=" * 70)

        channels = self.data.get('channels', [])

        print(f"\n{'Ch':<4} {'Type':<6} {'Distance':<10} {'Trim':<8} {'Filter Len':<12} {'FilterLV Len':<12} {'Xover'}")
        print("-" * 70)

        for i, ch in enumerate(channels):
            speaker_type = ch.get('speakerType', 'N/A')
            distance = f"{ch.get('distanceInMeters', 0):.2f}m"
            trim = f"{ch.get('trimAdjustmentInDbs', 0):.1f}dB"
            filter_len = len(ch.get('filter', []))
            filterLV_len = len(ch.get('filterLV', []))
            xover = ch.get('xover', 'N/A')

            print(f"{i:<4} {speaker_type:<6} {distance:<10} {trim:<8} {filter_len:<12} {filterLV_len:<12} {xover}")

        # Group by filter length
        print("\nGrouped by Filter Length:")
        from collections import defaultdict
        groups = defaultdict(list)
        for i, ch in enumerate(channels):
            filter_len = len(ch.get('filter', []))
            groups[filter_len].append(i)

        for length, channel_nums in sorted(groups.items()):
            print(f"  {length} coefficients: Channels {channel_nums}")

        print("=" * 70)


def main():
    """Main entry point"""
    if len(sys.argv) < 2:
        print(__doc__)
        sys.exit(1)

    command = sys.argv[1]

    # Find the .oca file
    oca_files = list(Path('.').glob('*.oca'))
    if not oca_files:
        print("Error: No .oca file found in current directory")
        sys.exit(1)

    oca_file = oca_files[0]
    analyzer = OCAAnalyzer(oca_file)

    # Execute commands
    if command == 'summary':
        analyzer.summary()

    elif command == 'list-channels':
        analyzer.list_channels()

    elif command == 'inspect-filter':
        if len(sys.argv) < 3:
            print("Usage: main.py inspect-filter <channel_num>")
            sys.exit(1)
        channel_num = int(sys.argv[2])
        analyzer.inspect_filter(channel_num)

    elif command == 'chunk-filter':
        if len(sys.argv) < 3:
            print("Usage: main.py chunk-filter <channel_num> [--start N] [--size N]")
            sys.exit(1)

        channel_num = int(sys.argv[2])
        start = 0
        size = 100

        # Parse optional arguments
        for i in range(3, len(sys.argv)):
            if sys.argv[i] == '--start' and i + 1 < len(sys.argv):
                start = int(sys.argv[i + 1])
            elif sys.argv[i] == '--size' and i + 1 < len(sys.argv):
                size = int(sys.argv[i + 1])

        analyzer.chunk_filter(channel_num, start, size)

    elif command == 'export-filter':
        if len(sys.argv) < 4:
            print("Usage: main.py export-filter <channel_num> <output_file.csv>")
            sys.exit(1)

        channel_num = int(sys.argv[2])
        output_file = sys.argv[3]
        analyzer.export_filter_csv(channel_num, output_file)

    elif command == 'compare-channels':
        analyzer.compare_channels()

    else:
        print(f"Unknown command: {command}")
        print(__doc__)
        sys.exit(1)


if __name__ == '__main__':
    main()
