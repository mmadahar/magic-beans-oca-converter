# A1 Evo Express .oca File Format Documentation

## Overview

The `.oca` file is a JSON-formatted configuration file generated by A1 Evo Express, a sound optimization tool for Audyssey-enabled Denon/Marantz AV receivers. This file contains calibration data including speaker configuration, distance measurements, trim levels, crossover settings, and most importantly, **FIR filter coefficients** for room correction.

## File Analysis

Based on the example file `A1EvoExpress_v2_Oct14_1933.oca`:
- **File size**: ~820KB (260,171 lines)
- **Format**: Standard JSON
- **Total channels**: 8 (6 surround + 2 height/effect)
- **Filter coefficients per channel**: ~16,000 values

---

## Top-Level Structure

### Main Properties

```json
{
  "A1EvoExpress": "2",           // Version number
  "model": "Marantz SR6012",     // Receiver model
  "eqType": 2,                   // EQ Type (likely refers to MultEQ XT32)
  "hasGriffinLiteDSP": false,    // DSP feature flag
  "isNewModel": false,           // Model generation flag
  "ampAssign": "Normal",         // Amplifier assignment mode
  "ampAssignInfo": "...",        // Hex-encoded amp configuration
  "numberOfSubwoofers": 2,       // Subwoofer count
  "lpfForLFE": 120,             // Low-pass filter for LFE (Hz)
  "bassMode": "LFE",            // Bass management mode
  "channels": [...]             // Array of channel objects (see below)
}
```

### Key Settings Explained

- **eqType**: Typically 2 for MultEQ XT32, 1 for MultEQ XT, 0 for basic MultEQ
- **ampAssign**: Speaker configuration mode (Normal, Bi-Amp, Front Height, etc.)
- **bassMode**: How bass is managed (LFE, LFE+Main, etc.)
- **lpfForLFE**: Low-pass filter frequency for the LFE channel (typically 80Hz or 120Hz)

---

## Channel Structure

Each channel in the `channels` array represents a speaker in your system.

### Channel Object Schema

```json
{
  "speakerType": "S",            // S=Surround, E=Effect/Height, C=Center, etc.
  "distanceInMeters": 2.75,      // Speaker distance from listening position
  "trimAdjustmentInDbs": -1.5,   // Volume trim adjustment
  "commandId": 1,                // Internal command identifier
  "xover": 80,                   // Crossover frequency (Hz), N/A for full-range
  "filter": [...],               // Main FIR filter coefficients
  "filterLV": [...]              // Secondary filter (possibly low-volume variant)
}
```

### Speaker Type Codes

Speaker type codes indicate **size configuration**, not physical location:
- **S**: Small speakers (use crossover, bass redirected to subwoofer)
- **E**: Large/Full-range speakers (no crossover, full-range audio)
- **C**: Center channel (location identifier)
- **F**: Front left/right (location identifier)
- **SW**: Subwoofer (location identifier)

**Important**: S and E refer to the "Small" vs "Large" speaker setting in Audyssey setup, which determines bass management behavior. This is why 'S' channels have crossover frequencies (60/80/100 Hz) while 'E' channels show N/A.

### Example Channel Breakdown

From the test file:

| Ch | Type | Distance | Trim  | Crossover | Filter Len | Notes                    |
|----|------|----------|-------|-----------|------------|--------------------------|
| 0  | S    | 2.75m    | -1.5dB| 80 Hz     | 16,321     | Small speaker (80Hz xover) |
| 1  | S    | 2.74m    | -2.0dB| 80 Hz     | 16,321     | Small speaker (80Hz xover) |
| 2  | S    | 2.49m    | -6.0dB| 60 Hz     | 16,321     | Small speaker (60Hz xover) |
| 3  | S    | 2.46m    | -6.0dB| 60 Hz     | 16,321     | Small speaker (60Hz xover) |
| 4  | S    | 4.28m    | 0.0dB | 100 Hz    | 16,321     | Small speaker (100Hz xover)|
| 5  | S    | 4.28m    | 0.0dB | 100 Hz    | 16,321     | Small speaker (100Hz xover)|
| 6  | E    | 3.55m    | -0.5dB| N/A       | 16,055     | Large/Full-range speaker   |
| 7  | E    | 4.65m    | -3.0dB| N/A       | 16,055     | Large/Full-range speaker   |

**Observation**: Small speakers (type S) have slightly longer filters (16,321) compared to Large speakers (16,055), likely due to additional bass management filtering.

---

## Filter Coefficients Deep Dive

### What Are These Filters?

The `filter` and `filterLV` arrays contain **FIR (Finite Impulse Response) filter coefficients**. These are used to:

1. **Correct frequency response** - Compensate for room acoustics and speaker deficiencies
2. **Apply target curves** - Shape the sound signature (e.g., Harman curve, flat response)
3. **Phase correction** - Time-align speakers and smooth phase response
4. **Dynamic EQ adjustments** - Volume-dependent frequency shaping

### Filter Characteristics

From analysis of Channel 0:

```
Total Coefficients: 16,321
Min Value: -0.0022820464
Max Value:  0.7202777211 (first coefficient - typically the gain/normalization)
Mean:       0.0000442343
Median:     0.0000006690
Std Dev:    0.0056418670
```

### Filter Structure Observations

1. **First coefficient is dominant**: The first value (~0.72) is the main gain coefficient
2. **Subsequent values are corrections**: Most values are very small (< 0.003)
3. **Symmetric taper**: Values gradually approach zero toward the end
4. **Linear-phase design**: Large filter length suggests linear-phase FIR design

### Filter Length Implications

- **16,321 coefficients** at typical sample rates:
  - At 48kHz: ~340ms of filter length (covers room reflections)
  - At 96kHz: ~170ms of filter length

This is consistent with room correction systems that need to address:
- Direct sound
- Early reflections (5-50ms)
- Late reverberation

### Example Filter Values

**First 10 coefficients (Channel 0):**
```
[0]  =  0.7202777211    ← Main gain
[1]  = -0.0022820464    ← Small correction
[2]  = -0.0022770030
[3]  = -0.0022710164
[4]  = -0.0022640926
[5]  = -0.0022562336
[6]  = -0.0022474478
[7]  = -0.0022377401
[8]  = -0.0022271158
[9]  = -0.0022155859
```

**Last 10 coefficients:**
```
[16311] = -0.0000022629
[16312] = -0.0000023364
[16313] = -0.0000024092
[16314] = -0.0000024819
[16315] = -0.0000025543
[16316] = -0.0000026262
[16317] = -0.0000026975
[16318] = -0.0000027686
[16319] = -0.0000028388
[16320] = -0.0000029089  ← Tails off to near-zero
```

---

## Frequency Response Relationship

### Converting Filters to Frequency Response

The FIR filter coefficients represent the **time-domain impulse response**. To understand their effect on frequency:

1. **Take FFT** of the filter coefficients
2. **Calculate magnitude** to get frequency response (dB vs Hz)
3. **Calculate phase** to see phase response

### Typical Audyssey Curve Characteristics

Based on the filter structure, A1 Evo Express likely applies:

- **Sub-bass boost** (20-60 Hz): Common in Audyssey curves
- **Reference curve** (100-2000 Hz): Attempts flat response
- **High-frequency rolloff** (8kHz+): Gentle rolloff for listening comfort
- **Room mode correction**: Notches at specific frequencies to combat resonances

---

## FilterLV - Low Volume Variant

The `filterLV` array appears to be a second set of filter coefficients, likely for:

- **Dynamic Volume/EQ**: Different filter applied at lower listening levels
- **Audyssey Dynamic EQ**: Frequency response changes based on volume (psychoacoustic compensation)

In the test file, `filterLV` has the **same length** as `filter` for each channel, suggesting it's a parallel filter set that's blended or switched based on listening level.

---

## Crossover Settings

### Crossover Frequencies

The `xover` field specifies where bass content is redirected to subwoofers:

- **60 Hz**: Small speakers or long distance from sub
- **80 Hz**: Most common (THX standard)
- **100 Hz**: Very small speakers
- **N/A**: Full-range speakers (no bass management)

### Effect on Filters

Channels with crossover settings have high-pass filtering applied via the FIR coefficients. The crossover is **not a separate parameter** but is baked into the filter design.

---

## How to Create Custom Target Curves

### Understanding Target Curves

A **target curve** defines the desired frequency response. Common curves include:

1. **Flat**: No EQ correction (0 dB across all frequencies)
2. **Harman Curve**: Gentle bass boost, slight high-frequency rolloff
3. **Reference**: Studio monitor-style response
4. **Custom**: User-defined curve based on preference

### Steps to Upload Custom Filters

Based on the file structure, here's how you would create custom filters:

#### 1. Generate Your Desired Frequency Response

Use Room EQ Wizard (REW) or similar tools:
- Measure your room's response
- Create a target curve
- Generate correction filters

#### 2. Export FIR Filter Coefficients

From REW or MATLAB/Python:
```python
import numpy as np
from scipy.signal import firwin

# Example: Design a simple filter
taps = 16321  # Match the .oca filter length
nyquist = sample_rate / 2
cutoff_freq = 80  # Crossover frequency

# Design FIR filter
coefficients = firwin(taps, cutoff_freq, window='hamming', fs=sample_rate)

# Normalize (first coefficient should be near 0.7-0.9)
coefficients = coefficients / np.max(np.abs(coefficients)) * 0.72
```

#### 3. Replace Filter Arrays

Load the `.oca` file and replace the `filter` array:

```python
import json

with open('original.oca', 'r') as f:
    data = json.load(f)

# Replace channel 0's filter
data['channels'][0]['filter'] = your_custom_coefficients.tolist()

# Keep filterLV the same or create a low-volume variant
data['channels'][0]['filterLV'] = your_low_volume_coefficients.tolist()

with open('modified.oca', 'w') as f:
    json.dump(data, f)
```

#### 4. Validation Checks

Before uploading to your receiver:

✅ **Filter length matches**: Must be 16,321 or 16,055 (depending on speaker type)
✅ **First coefficient normalized**: Typically 0.5 - 0.9 for proper gain
✅ **Values in reasonable range**: Most should be < 0.01 in absolute value
✅ **Smooth transitions**: No abrupt jumps between coefficients
✅ **Crossover alignment**: If `xover` is set, ensure high-pass filtering is applied

#### 5. Test Gradually

- Start with **one channel** to verify
- Use a **lower gain** initially (multiply all coefficients by 0.5)
- Test at **low volume** first to ensure no clipping or distortion

---

## Advanced Topics

### Linear-Phase vs Minimum-Phase

The large filter size (16,321 taps) suggests **linear-phase filtering**:

**Advantages:**
- No phase distortion
- Symmetrical pre/post-ringing
- Better for time-domain accuracy

**Disadvantages:**
- Large pre-ring (sound "before" the impulse)
- Higher latency
- More computational load

Audyssey typically uses linear-phase filtering for its precision, though this introduces ~170-340ms latency.

### AmpAssignInfo Field

The `ampAssignInfo` field is a hex-encoded configuration string:
```
0002030001010000010001000400200020000400200010000100200002080108021000010203040500010600
```

This likely encodes:
- Channel routing (which physical amp powers which speaker)
- Bi-amp configurations
- Height speaker assignments
- Subwoofer configurations

**Recommendation**: Do not modify this field unless you fully understand your receiver's amp architecture.

---

## Tools for Analysis

### Using the Included `main.py`

```bash
# View overall configuration
uv run python main.py summary

# List all channels
uv run python main.py list-channels

# Inspect specific channel's filter
uv run python main.py inspect-filter 0

# View filter in chunks
uv run python main.py chunk-filter 0 --start 1000 --size 50

# Export filter for analysis
uv run python main.py export-filter 0 channel_0.csv

# Compare all channels
uv run python main.py compare-channels
```

### Python Analysis Example

```python
import json
import numpy as np
import matplotlib.pyplot as plt
from scipy.fft import fft, fftfreq

# Load OCA file
with open('A1EvoExpress_v2_Oct14_1933.oca', 'r') as f:
    data = json.load(f)

# Extract filter from channel 0
filter_coeffs = np.array(data['channels'][0]['filter'])

# Compute frequency response
sample_rate = 48000  # Typical for Audyssey
freq_response = fft(filter_coeffs)
freqs = fftfreq(len(filter_coeffs), 1/sample_rate)

# Plot magnitude response
plt.figure(figsize=(12, 6))
plt.subplot(2, 1, 1)
plt.plot(freqs[:len(freqs)//2], 20*np.log10(np.abs(freq_response[:len(freqs)//2])))
plt.xlabel('Frequency (Hz)')
plt.ylabel('Magnitude (dB)')
plt.xscale('log')
plt.grid(True)
plt.title('Channel 0 Frequency Response')

# Plot phase response
plt.subplot(2, 1, 2)
plt.plot(freqs[:len(freqs)//2], np.angle(freq_response[:len(freqs)//2]))
plt.xlabel('Frequency (Hz)')
plt.ylabel('Phase (radians)')
plt.xscale('log')
plt.grid(True)
plt.tight_layout()
plt.show()
```

---

## Safety and Best Practices

### ⚠️ Important Warnings

1. **Backup original files**: Always keep a copy of your working `.oca` file
2. **Test incrementally**: Don't modify all channels at once
3. **Volume protection**: Improper filters can cause clipping or speaker damage
4. **Receiver compatibility**: Ensure your receiver supports the file format
5. **Use official tools**: A1 Evo Express validates filters - use it when possible

### Recommended Workflow

1. **Export** existing filters using `main.py export-filter`
2. **Analyze** in REW or similar tools to understand current tuning
3. **Create** new target curve based on measurements
4. **Generate** FIR filters matching the exact length
5. **Validate** coefficients are in reasonable ranges
6. **Modify** one channel's filter in the JSON file
7. **Test** at low volume with single channel
8. **Expand** to other channels once validated
9. **Document** your changes for future reference

---

## Future Enhancement Ideas

### Automated Filter Generation Tool

Create a script that:
1. Takes a target curve CSV (frequency vs dB)
2. Generates FIR coefficients at the correct length
3. Automatically updates the `.oca` file
4. Validates all constraints
5. Provides frequency response plots for verification

### Multi-Point Optimization

Design filters that optimize for:
- Multiple listening positions
- Different frequency weightings per position
- Phase alignment between speakers

### Dynamic Range Optimization

Create separate `filter` and `filterLV` that:
- Maintain consistent tonality across volumes
- Apply psychoacoustic compensation
- Preserve dynamics while correcting response

---

## Conclusion

The `.oca` file format is a comprehensive container for Audyssey room correction data. The most critical component for custom tuning is the **filter arrays**, which contain FIR filter coefficients representing your target curve and room corrections.

### Key Takeaways

✅ **16,321 coefficient FIR filters** represent time-domain impulse responses
✅ **First coefficient is normalization gain** (typically 0.5-0.9)
✅ **Linear-phase design** provides accurate response with latency tradeoff
✅ **FilterLV is a parallel filter set** for dynamic volume/EQ
✅ **Crossover frequencies are baked into filters**, not separate processing
✅ **Match filter lengths exactly** when creating custom filters

Use the provided `main.py` tool to explore your own `.oca` files and gain deeper insights into your system's calibration!

---

## References and Resources

- **A1 Evo Express**: https://www.oca1evo.com/
- **Audyssey MultEQ**: Official Denon/Marantz calibration system
- **Room EQ Wizard (REW)**: https://www.roomeqwizard.com/
- **FIR Filter Design**: https://en.wikipedia.org/wiki/Finite_impulse_response
- **Harman Curve**: https://www.harmankardon.com/

---

**Document Version**: 1.0
**Last Updated**: October 2024
**Author**: Generated via Claude Code analysis
